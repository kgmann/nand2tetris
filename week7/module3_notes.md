## Summary
The part II of the course is mainly about bridging the gap between the Hack hardware and machine language that we worked on in part I, and a modern software layer that allows us to write programs in high level languages (Jack) and run them on the Hack computer seamlessly.
They are many pieces needed to achieve that, and this week is mainly focused on the virtual machine and the stack. But at a high level, it's very much about all the main steps needed to break down a program written in a high level language to run on a given hardware.

We can break the whole thing down into 2 main pieces. 1) A two tier compilation process to go from the high level language to an intermediate level language, and from that intermediate language to a low level language directly supported by the target hardware (e.g. Hack assembly); 2) An Operating system to help with various other things.

This week, we'll mainly focus on going from the intermediate level language (VM code) to assembly instructions without caring much yet about how we got the instructions for the intermediate language. The main reason why we're using an intermediate language here in the fisrt place instead of just writing one compiler that compiles to machine code directly is because it makes it easier to target different computer hardware. So the idea here is, instead of writing one gigantic compiler for every possible hardware we want our language to support, we first write a compiler that compiles the code for a hypothetical machine, which is the stack machine in our case. The output of that compiler is VM code. We then write a second compiler/translator, that translates the generated VM code generated to hack assembly code. We can do this by mapping some RAM memory regions to represent the memory segments of the stack machine. So we write one VM translator for each of  the hardware platforms we want to target. 

Stack machines are conceptually simple yet powerful abstractions that use a stack data structure and memory segments. We have a stack, a stack pointer and a set of two fundamental commands (push and pop) that involve pushing or poping from the stack while reading or saving data to the memory segments. We also have a set of arthmetic / logical commands that can be executed by the stack machine  (add, sub, lt, neg, etc...) that operate on the top element or the two top entries of the stack depending on whether it's a unary or binary arithmetic or logical operation.

Our VM code / language consists of four categories of commands: arithmetic and logical commands; memory segment commands; branching commands; function commands. 
The assignment was to implement a VM translator to convert the VM code to hack machine code. The main idea for the implementation is to map the stack and the memory segments of the stack machine to memory regions in our RAM. Our stack machine can then be implemented in any language, as long as the generated machine code is valid and works on the Hack computer. Pointers manipulation is key in the Hack machine language to be able to write the stack machine.
In project 7 (current project), we're only building a part of the VM translator (arithmetic and logical commands and memory commands). We'll deal with the rest in the next project.

## Terminologies
compilation, virtualization, VM abstraction, Stack Processing, VM implementation, Pointers, virtual machines, two tier compilation, VM code, bytecode, language frontend, language backend, vm abstraction, stack machine, memory segments.


## Other Notes
- I might want to read a bit more about pushdown automata later.
- I like how they used memory segments to make it easier to manage variable scopes and I'd be glad to learn more about it later.
- I might want to implement the stack machine in Hack assembly ? Would probably be a whole lot of work but sounds exciting (Nah, too much work. Way too much).
- I'm very interested in knowing how they came up with the design for the VM language, going from the high level language. And are they other types of VM languages that are not stack and memory segments based like the one we're using ? I know we'll go over the first compilation part where we compile the high level language to the VM code, but before that I feel like they might be so many different ways of doing that, so I'm wondering how we ended choosing a VM language designed for a stack based VM. My best ansewr for now is that at the lowest level, the copmuter is mainly about unary and binary operations on data registers, and some memory operations (store and retrieve). So a VM language that is close to the machine should have commands that easily supports those operations and it's the case for the stack based virtual machine.
- One cool thing that I'm realising as I'm going through this chapter is that computers are just ... fancy calculators at their core. And very much all the things that we can do in a modern high level languages can be broken down to just a bunch of basic arithmetic/logical operation and register / memory manipulation operations on a computer. All the wild things we can write (games, web apps, software, etc...) are just about that. And I think this changes a bit my perspectives about computers. The fact that some brilliant minds have been able to forsee the potential of such simple machine long time ago is very intriguing to me. Like how could you think we could do all those things with such a simple machine. It makes me more interested in computing history and theories. I should dive a bit deeper into that later.
- I like their VM Emulator, it's a simple and cool piece of software.
- Writing the VM translator was pretty cool
- I wrote my VM translator in Python, so I can only run it on a platform that supports Python. Which is not the case yet for the Hack computer cause we don't have a C compiler for it (to run CPython for example). So my question is how did people write the first VM translators or compilers when no higher level langauges didn't exist before ? Was it in the assembly language of each target machine ? Like for example the first C compiler was written in the assembly language of a target machine, or at least the first version of the language before self hosting itself ? ----- (Searched this and I'm mostly right. It was mainly about bootstraping, and using cross compilers. I ommited the assembler here, but yeah the main idea is there. You write the assembler in binary, then subsequent programs in assembly and later in higher level languages.)
- Following up on the previous point, how would the first assemblers work though ? I mean we would need to write characters (and numbers), that the assembler would translate to binary code right ? how do we insert those characters in the computer if we don't have things like file systems, character encoding standards or libraries, etc... Cause the first assemblers would be burned in binary on a ROM right ? So how do we represent the programs to assemble ? ----- (Searched this too and it seems like the first programers were doing some wild engineering feats to make this all work. Loading programing on punched cards etc...). I migh tread more about this later.